//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SinkInitParameters) DeepCopyInto(out *SinkInitParameters) {
	*out = *in
	if in.AwsAccountID != nil {
		in, out := &in.AwsAccountID, &out.AwsAccountID
		*out = new(string)
		**out = **in
	}
	if in.AwsPartnerEventSource != nil {
		in, out := &in.AwsPartnerEventSource, &out.AwsPartnerEventSource
		*out = new(string)
		**out = **in
	}
	if in.AwsRegion != nil {
		in, out := &in.AwsRegion, &out.AwsRegion
		*out = new(string)
		**out = **in
	}
	if in.AzurePartnerTopic != nil {
		in, out := &in.AzurePartnerTopic, &out.AzurePartnerTopic
		*out = new(string)
		**out = **in
	}
	if in.AzureRegion != nil {
		in, out := &in.AzureRegion, &out.AzureRegion
		*out = new(string)
		**out = **in
	}
	if in.AzureResourceGroup != nil {
		in, out := &in.AzureResourceGroup, &out.AzureResourceGroup
		*out = new(string)
		**out = **in
	}
	if in.AzureSubscriptionID != nil {
		in, out := &in.AzureSubscriptionID, &out.AzureSubscriptionID
		*out = new(string)
		**out = **in
	}
	if in.DatadogAPIKeySecretRef != nil {
		in, out := &in.DatadogAPIKeySecretRef, &out.DatadogAPIKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.DatadogRegion != nil {
		in, out := &in.DatadogRegion, &out.DatadogRegion
		*out = new(string)
		**out = **in
	}
	if in.HTTPAuthorizationSecretRef != nil {
		in, out := &in.HTTPAuthorizationSecretRef, &out.HTTPAuthorizationSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.HTTPContentFormat != nil {
		in, out := &in.HTTPContentFormat, &out.HTTPContentFormat
		*out = new(string)
		**out = **in
	}
	if in.HTTPContentType != nil {
		in, out := &in.HTTPContentType, &out.HTTPContentType
		*out = new(string)
		**out = **in
	}
	if in.HTTPCustomHeaders != nil {
		in, out := &in.HTTPCustomHeaders, &out.HTTPCustomHeaders
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.HTTPEndpoint != nil {
		in, out := &in.HTTPEndpoint, &out.HTTPEndpoint
		*out = new(string)
		**out = **in
	}
	if in.MixpanelProjectID != nil {
		in, out := &in.MixpanelProjectID, &out.MixpanelProjectID
		*out = new(string)
		**out = **in
	}
	if in.MixpanelRegion != nil {
		in, out := &in.MixpanelRegion, &out.MixpanelRegion
		*out = new(string)
		**out = **in
	}
	if in.MixpanelServiceAccountPasswordSecretRef != nil {
		in, out := &in.MixpanelServiceAccountPasswordSecretRef, &out.MixpanelServiceAccountPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.MixpanelServiceAccountUsername != nil {
		in, out := &in.MixpanelServiceAccountUsername, &out.MixpanelServiceAccountUsername
		*out = new(string)
		**out = **in
	}
	if in.SegmentWriteKeySecretRef != nil {
		in, out := &in.SegmentWriteKeySecretRef, &out.SegmentWriteKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SplunkDomain != nil {
		in, out := &in.SplunkDomain, &out.SplunkDomain
		*out = new(string)
		**out = **in
	}
	if in.SplunkPort != nil {
		in, out := &in.SplunkPort, &out.SplunkPort
		*out = new(string)
		**out = **in
	}
	if in.SplunkSecure != nil {
		in, out := &in.SplunkSecure, &out.SplunkSecure
		*out = new(bool)
		**out = **in
	}
	if in.SplunkTokenSecretRef != nil {
		in, out := &in.SplunkTokenSecretRef, &out.SplunkTokenSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SumoSourceAddress != nil {
		in, out := &in.SumoSourceAddress, &out.SumoSourceAddress
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SinkInitParameters.
func (in *SinkInitParameters) DeepCopy() *SinkInitParameters {
	if in == nil {
		return nil
	}
	out := new(SinkInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SinkObservation) DeepCopyInto(out *SinkObservation) {
	*out = *in
	if in.AwsAccountID != nil {
		in, out := &in.AwsAccountID, &out.AwsAccountID
		*out = new(string)
		**out = **in
	}
	if in.AwsPartnerEventSource != nil {
		in, out := &in.AwsPartnerEventSource, &out.AwsPartnerEventSource
		*out = new(string)
		**out = **in
	}
	if in.AwsRegion != nil {
		in, out := &in.AwsRegion, &out.AwsRegion
		*out = new(string)
		**out = **in
	}
	if in.AzurePartnerTopic != nil {
		in, out := &in.AzurePartnerTopic, &out.AzurePartnerTopic
		*out = new(string)
		**out = **in
	}
	if in.AzureRegion != nil {
		in, out := &in.AzureRegion, &out.AzureRegion
		*out = new(string)
		**out = **in
	}
	if in.AzureResourceGroup != nil {
		in, out := &in.AzureResourceGroup, &out.AzureResourceGroup
		*out = new(string)
		**out = **in
	}
	if in.AzureSubscriptionID != nil {
		in, out := &in.AzureSubscriptionID, &out.AzureSubscriptionID
		*out = new(string)
		**out = **in
	}
	if in.DatadogRegion != nil {
		in, out := &in.DatadogRegion, &out.DatadogRegion
		*out = new(string)
		**out = **in
	}
	if in.HTTPContentFormat != nil {
		in, out := &in.HTTPContentFormat, &out.HTTPContentFormat
		*out = new(string)
		**out = **in
	}
	if in.HTTPContentType != nil {
		in, out := &in.HTTPContentType, &out.HTTPContentType
		*out = new(string)
		**out = **in
	}
	if in.HTTPCustomHeaders != nil {
		in, out := &in.HTTPCustomHeaders, &out.HTTPCustomHeaders
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.HTTPEndpoint != nil {
		in, out := &in.HTTPEndpoint, &out.HTTPEndpoint
		*out = new(string)
		**out = **in
	}
	if in.MixpanelProjectID != nil {
		in, out := &in.MixpanelProjectID, &out.MixpanelProjectID
		*out = new(string)
		**out = **in
	}
	if in.MixpanelRegion != nil {
		in, out := &in.MixpanelRegion, &out.MixpanelRegion
		*out = new(string)
		**out = **in
	}
	if in.MixpanelServiceAccountUsername != nil {
		in, out := &in.MixpanelServiceAccountUsername, &out.MixpanelServiceAccountUsername
		*out = new(string)
		**out = **in
	}
	if in.SplunkDomain != nil {
		in, out := &in.SplunkDomain, &out.SplunkDomain
		*out = new(string)
		**out = **in
	}
	if in.SplunkPort != nil {
		in, out := &in.SplunkPort, &out.SplunkPort
		*out = new(string)
		**out = **in
	}
	if in.SplunkSecure != nil {
		in, out := &in.SplunkSecure, &out.SplunkSecure
		*out = new(bool)
		**out = **in
	}
	if in.SumoSourceAddress != nil {
		in, out := &in.SumoSourceAddress, &out.SumoSourceAddress
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SinkObservation.
func (in *SinkObservation) DeepCopy() *SinkObservation {
	if in == nil {
		return nil
	}
	out := new(SinkObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SinkParameters) DeepCopyInto(out *SinkParameters) {
	*out = *in
	if in.AwsAccountID != nil {
		in, out := &in.AwsAccountID, &out.AwsAccountID
		*out = new(string)
		**out = **in
	}
	if in.AwsPartnerEventSource != nil {
		in, out := &in.AwsPartnerEventSource, &out.AwsPartnerEventSource
		*out = new(string)
		**out = **in
	}
	if in.AwsRegion != nil {
		in, out := &in.AwsRegion, &out.AwsRegion
		*out = new(string)
		**out = **in
	}
	if in.AzurePartnerTopic != nil {
		in, out := &in.AzurePartnerTopic, &out.AzurePartnerTopic
		*out = new(string)
		**out = **in
	}
	if in.AzureRegion != nil {
		in, out := &in.AzureRegion, &out.AzureRegion
		*out = new(string)
		**out = **in
	}
	if in.AzureResourceGroup != nil {
		in, out := &in.AzureResourceGroup, &out.AzureResourceGroup
		*out = new(string)
		**out = **in
	}
	if in.AzureSubscriptionID != nil {
		in, out := &in.AzureSubscriptionID, &out.AzureSubscriptionID
		*out = new(string)
		**out = **in
	}
	if in.DatadogAPIKeySecretRef != nil {
		in, out := &in.DatadogAPIKeySecretRef, &out.DatadogAPIKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.DatadogRegion != nil {
		in, out := &in.DatadogRegion, &out.DatadogRegion
		*out = new(string)
		**out = **in
	}
	if in.HTTPAuthorizationSecretRef != nil {
		in, out := &in.HTTPAuthorizationSecretRef, &out.HTTPAuthorizationSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.HTTPContentFormat != nil {
		in, out := &in.HTTPContentFormat, &out.HTTPContentFormat
		*out = new(string)
		**out = **in
	}
	if in.HTTPContentType != nil {
		in, out := &in.HTTPContentType, &out.HTTPContentType
		*out = new(string)
		**out = **in
	}
	if in.HTTPCustomHeaders != nil {
		in, out := &in.HTTPCustomHeaders, &out.HTTPCustomHeaders
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.HTTPEndpoint != nil {
		in, out := &in.HTTPEndpoint, &out.HTTPEndpoint
		*out = new(string)
		**out = **in
	}
	if in.MixpanelProjectID != nil {
		in, out := &in.MixpanelProjectID, &out.MixpanelProjectID
		*out = new(string)
		**out = **in
	}
	if in.MixpanelRegion != nil {
		in, out := &in.MixpanelRegion, &out.MixpanelRegion
		*out = new(string)
		**out = **in
	}
	if in.MixpanelServiceAccountPasswordSecretRef != nil {
		in, out := &in.MixpanelServiceAccountPasswordSecretRef, &out.MixpanelServiceAccountPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.MixpanelServiceAccountUsername != nil {
		in, out := &in.MixpanelServiceAccountUsername, &out.MixpanelServiceAccountUsername
		*out = new(string)
		**out = **in
	}
	if in.SegmentWriteKeySecretRef != nil {
		in, out := &in.SegmentWriteKeySecretRef, &out.SegmentWriteKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SplunkDomain != nil {
		in, out := &in.SplunkDomain, &out.SplunkDomain
		*out = new(string)
		**out = **in
	}
	if in.SplunkPort != nil {
		in, out := &in.SplunkPort, &out.SplunkPort
		*out = new(string)
		**out = **in
	}
	if in.SplunkSecure != nil {
		in, out := &in.SplunkSecure, &out.SplunkSecure
		*out = new(bool)
		**out = **in
	}
	if in.SplunkTokenSecretRef != nil {
		in, out := &in.SplunkTokenSecretRef, &out.SplunkTokenSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.SumoSourceAddress != nil {
		in, out := &in.SumoSourceAddress, &out.SumoSourceAddress
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SinkParameters.
func (in *SinkParameters) DeepCopy() *SinkParameters {
	if in == nil {
		return nil
	}
	out := new(SinkParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Stream) DeepCopyInto(out *Stream) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Stream.
func (in *Stream) DeepCopy() *Stream {
	if in == nil {
		return nil
	}
	out := new(Stream)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Stream) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamInitParameters) DeepCopyInto(out *StreamInitParameters) {
	*out = *in
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.IsPriority != nil {
		in, out := &in.IsPriority, &out.IsPriority
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Sink != nil {
		in, out := &in.Sink, &out.Sink
		*out = make([]SinkInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamInitParameters.
func (in *StreamInitParameters) DeepCopy() *StreamInitParameters {
	if in == nil {
		return nil
	}
	out := new(StreamInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamList) DeepCopyInto(out *StreamList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Stream, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamList.
func (in *StreamList) DeepCopy() *StreamList {
	if in == nil {
		return nil
	}
	out := new(StreamList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *StreamList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamObservation) DeepCopyInto(out *StreamObservation) {
	*out = *in
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IsPriority != nil {
		in, out := &in.IsPriority, &out.IsPriority
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Sink != nil {
		in, out := &in.Sink, &out.Sink
		*out = make([]SinkObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamObservation.
func (in *StreamObservation) DeepCopy() *StreamObservation {
	if in == nil {
		return nil
	}
	out := new(StreamObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamParameters) DeepCopyInto(out *StreamParameters) {
	*out = *in
	if in.Filters != nil {
		in, out := &in.Filters, &out.Filters
		*out = make([]map[string]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = make(map[string]*string, len(*in))
				for key, val := range *in {
					var outVal *string
					if val == nil {
						(*out)[key] = nil
					} else {
						inVal := (*in)[key]
						in, out := &inVal, &outVal
						*out = new(string)
						**out = **in
					}
					(*out)[key] = outVal
				}
			}
		}
	}
	if in.IsPriority != nil {
		in, out := &in.IsPriority, &out.IsPriority
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Sink != nil {
		in, out := &in.Sink, &out.Sink
		*out = make([]SinkParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamParameters.
func (in *StreamParameters) DeepCopy() *StreamParameters {
	if in == nil {
		return nil
	}
	out := new(StreamParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamSpec) DeepCopyInto(out *StreamSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamSpec.
func (in *StreamSpec) DeepCopy() *StreamSpec {
	if in == nil {
		return nil
	}
	out := new(StreamSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StreamStatus) DeepCopyInto(out *StreamStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StreamStatus.
func (in *StreamStatus) DeepCopy() *StreamStatus {
	if in == nil {
		return nil
	}
	out := new(StreamStatus)
	in.DeepCopyInto(out)
	return out
}
